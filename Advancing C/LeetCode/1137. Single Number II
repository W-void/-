// 难受
1137. Single Number II

Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:

Input: [2,2,3,2]
Output: 3
Example 2:

Input: [0,1,0,1,0,1,99]
Output: 99
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int one = 0, two = 0, three = 0, size = nums.size();
        while(size-- > 0){
            two |= one & nums[size]; // 出现次数大于等于2的
            one ^= nums[size]; // 出现次数是奇数的
            three = two & one;  //所以one和two相交就是出现3次的
            two &= ~three;
            one &= ~three;
        }
        return one;
    }
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ones = 0, twos = 0;
        for(int i = 0; i < nums.size(); i++){
            ones = (ones ^ nums[i]) & ~twos; //(ones ^ nums[i])可能是1次或3次,若是3次twos对应位置必是1，若是1次twos对应位置必是0
            twos = (twos ^ nums[i]) & ~ones; //(twos ^ nums[i])要调整为1^1=0,1^0=1,0^1=0,0^0=0，即0^1不是普通的异或
        }
        return ones;    
    }
};
